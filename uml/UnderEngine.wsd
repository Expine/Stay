@startuml UnderEngine

package under {
    package base {
        abstract EngineBuilder {
            {abstract} #makeEngine() : Engine
            {abstract} #makeInput() : Input
            {abstract} #makeContext() : Context
            {abstract} #makeMusic() : Music
            {abstract} #makeSceneManager() : SceneManager
            +build() : Engine
        }
        abstract Engine {
            #input : Input
            #screen : Screen
            #manager : SceneManager
            #context : Context
            #music : Music
            +setInput(input)
            +setScreen(screen)
            +setContext(context)
            +setSceneManager(manager)
            +setMusic(music)
            +execute(scene)
            {abstract} #main()
        }

        package input {
            abstract Input {
                {static} +it : Input /' Singleton '/
                #screen : Screen
                #target : Element
                +setScreen(screen)
                {abstract} #onMouseMove(mouseEvent)
                {abstract} #onMouseDown(mouseEvent)
                {abstract} #onMouseUp(mouseEvent)
                {abstract} #onKeyDown(keyEvent)
                {abstract} #onKeyUp(keyEvent)
                {abstract} #clear()
                {abstract} +update()
                {abstract} +getMouseX() : number
                {abstract} +getMouseY() : number
                {abstract} +isMousePress(code) : bool
                {abstract} +isMousePressed(code) : bool
                {abstract} +isKeyPress(code) : bool
                {abstract} +isKeyPressed(code) : bool
            }
        }

        package screen {
            abstract Screen {
                +Screen(width, height) : Screen
                {static} +it : Screen /' Singleton '/
                +gameSize : number
                +width : number
                +height : number
                {abstract} +getTarget() : Element
                {abstract} +getCanvas() : Canvas
            }
        }

        package music {
            abstract Music {
                {static} +it : Music /' Singleton '/
                {abstract} +loadMusic(filePath) : number
                {abstract} +unloadMusic(musicID)
                {abstract} +playSE(musicID)
                {abstract} +playBGM(musicID)
                {abstract} +pauseBGM()
                {abstract} +resumeBGM()
                {abstract} +stopBGM()
            }
        }

        package context {
            abstract Context {
                #screen : Screen
                #image : ContextImage
                +setScreen(screen)
                {abstract} +setContextImage(contextImage)
                {abstract} +setFontColorByame(colorName)
                {abstract} +setFontColorByRGB(r,g,b)
                {abstract} +setFontSize(size)
                {abstract} +setFontName(fontName)
                {abstract} +preRendering()
                {abstract} +postRendering()
                {abstract} +fillText(text,x,y,anchorX,anchorY,size,color,font)
                {abstract} +strokeLine(sx,sy,ex,ey,color,lineWidth)
                {abstract} +strokeCircle(x,y,radius,startAngle,endAngle,anticlockwise,color,lineWidth)
                {abstract} +strokeRect(x,y,width,height,color,lineWidth)
                {abstract} +drawImage(imageID,x,y,width,height,srcX,srcY,srcW,srcH)
            }
            abstract ContextImage {
                {static} +it : ContextImage /' Singleton '/
                {abstract} +loadImage(filePath) : number
                {abstract} +getImage(id) : Image
            }
        }

        package scene {
            abstract SceneManager {
                {static} +it : SceneManager /' Singleton '/
                {abstract} +getScene() : Scene
                {abstract} +pushScene(scene)
                {abstract} +popScene()
                {abstract} +replaceScene(scene)
                {abstract} +update(dt)
                {abstract} +render(ctx)
            }
            abstract Scene {
                {abstract} +init()
                {abstract} +update(dt)
                {abstract} +render(ctx)
            }
        }

        package layer {
            abstract Layer {
                {abstract} +update(dt)
                {abstract} +render(ctx)
            }
        }

        package stage {
            abstract Stage {
                #map : Map
                #camera : Camera
                #physic : PhysicalWorld
                +setMap(map)
                +setCamera(camera)
                +setPhysicalWorld(physic)
                {abstract} +addEntity(entity)
                {abstract} +removeEntity(entity)
                {abstract} +setEnable(enable)
                {abstract} +update(dt)
                {abstract} +render(ctx,shiftX,shiftY)
            }
            package parser {
                abstract StageParser {
                    {abstract} +parse(filePath,width,height) : Stage
                }
            }
            package map {
                abstract Map {
                    +Map(width,height) : Map
                    +width : number
                    +height : number
                    {abstract} +update(dt)
                    {abstract} +render(ctx,shiftX,shiftY)
                }
            }
            package camera {
                abstract Camera {
                    +Camera(screenWidth,screenHeight) : Camera
                    +cameraX : number
                    +cameraY : number
                    +screenWidth : number
                    +screenHeight : number
                    +setCameraPosition(x,y,width,height)
                }
            }
            package entity {
                abstract Entity {
                    +Entity(x,y,width,height,imageID)
                    +x : number
                    +y : number
                    +width : number
                    +height : number
                    #imageID : number
                    +directionX : number
                    +directionY : number
                    +stage : Stage
                    +collider : Collider
                    +material : Material
                    +setStage(stage)
                    +setCollider(collider)
                    +setMaterial(material)
                    {abstract} +update(dt)
                    {abstract} +render(ctx,shiftX,shiftY)
                }
                abstract ImmutableObject {

                }
                abstract MutableObject {
                    +body : RigidBody
                    +setRigidBody(body)
                    +deltaMove(dx,dy)
                }
                abstract AutonomyObject {
                    {abstract} +addAI(ai,priotiy)
                    {abstract} +removeAI(ai)
                }

                abstract BreakableObject {
                    {abstract} +getHP() : number
                    {abstract} +damage(damage)
                    {abstract} +destroy()
                }
            }
            package physics {
                abstract PhysicalWorld {
                    +PhysicalWorld(gravity) : PhysicalWorld
                    #gravity : number
                    #response : CollisionResponse
                    +setResponse(response)
                    {abstract} +addActor(actor)
                    {abstract} +addEntity(entity)
                    {abstract} +removeEntity(entity)
                    {abstract} +update(dt)
                }
                abstract CollisionResponse {
                    +collisionResponse(data,dt)
                }
                package collider {
                    abstract Collider {
                        #aabb : AABB
                        +collisions : Array<CollisionData>
                        +isResponse : bool
                        +enable : bool
                        #entity : Entity
                        +init()
                        +setEntity(entity)
                        +addCollision(collision)
                        +getAABB() : AABB
                        {abstract} +isInCollider(x,y) : bool
                        {abstract} +isCollision(collider,data)
                        +isCollisionRoughly(collider)
                        {abstract} +update()
                        {abstract} +render(ctx,shiftX,shiftY)
                    }
                    class AABB {
                        +startX : number
                        +startY : number
                        +endX : number
                        +endY : number
                    }
                    class CollisionData {
                        +CollisionData(e1,e2,nx,ny,depth) : CollisionData
                        +e1 : Entity
                        +e2 : Entity
                        +nx : number
                        +ny : number
                        +depth : number
                    }
                }
                package material {
                    abstract Material {
                        +Material(mass,elasticity,mu) : Material
                        +mass : number
                        +e : number
                        +mu : number
                    }
                }
                package body {
                    abstract RigidBody {
                        #velocityX : number
                        #velocityY : number
                        #accelerationX : number
                        #accelerationY : number
                        +preVelocityX : number
                        +preVelocityY : number
                        +preAccelerationX : number
                        +preAccelerationY : number
                        +k : number
                        #entity : Entity
                        +setEntity(entity)
                        {abstract} +setNextAddVelocity(vx,vy)
                        {abstract} +update(dt)
                    }
                }
            }
            package ai {
                abstract AI {
                    #entity : AutonomyObject
                    +setEntity(entity)
                    {abstract} +init()
                    {abstract} +apply(dt) : bool
                }
                abstract StateAI {
                    {abstract} +getState() : State
                    {abstract} +changeState(state)
                }
                abstract State {
                    #entity : AutonomyObject
                    #ai : StateAI
                    +setEntity(entity)
                    +setAI(ai)
                    {abstract} +init()
                    {abstract} +apply(dt) : bool
                    {abstract} +render(ctx.shiftX,shiftY)
                }
            }
        }
    }
}

EngineBuilder ..> Engine
Engine "1" *-- "1" Screen
Engine "1" *-- "1" Input
Engine "1" *-- "1" SceneManager
Engine "1" *-- "1" Context
Engine "1" *-- "1" Music

Input .> Screen
Context .> Screen

SceneManager "1" *-- "*" Scene
Scene "1" o-- "*" Layer
Context "1" *-- "1" ContextImage

StageParser --> Stage
Stage "1" *-- "1" Map
Stage "1" *-- "1" Camera
Stage "1" *-- "*" Entity
Stage "1" *-- "1" PhysicalWorld
PhysicalWorld "1"*--"*" Entity

Entity <|-- ImmutableObject
Entity <|-- MutableObject
MutableObject <|-- AutonomyObject
AutonomyObject <|-- BreakableObject

Entity "1" o-- "1" Collider
Entity "1" o-- "1" Material
RigidBody "1" --* "1" MutableObject
AutonomyObject "1" *-- "*" AI
AI <|-- StateAI
StateAI "1"*--"1" State

PhysicalWorld "1" *-- "1" CollisionResponse
Collider "1" o-- "*" CollisionData
Collider "1" *-- "1" AABB

@enduml
